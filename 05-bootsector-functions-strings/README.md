*Концепции, которые можно изучить сначала:: управляющие конструкции,
вызовы функций, строки*

**Цель: Изучить как кодировать основные конструкции (циклы, функции) в ассемблере**

Закроем наш последний загрузочный сектор.

В 7 уроке мы начнем читать с диска, последний шаг перед загрузкой ядра. Но прежде, напишем немного кода с 
использованием управляющих конструкций, вызовов функций и поработаем с целыми строками. Просто необходимо, для полного
комфорта, познакомиться с этимим концепциями. А после перейдем к диску и ядру.

Строки
-------

Определите строки побайтно и обязательно, в конце строки, поставьте нулевой байт (прямо как в си) для того, чтобы
точно определить ее окончание.

```nasm
mystring:
    db 'Hello, World', 0
```
Обратите внимание, что текст, заключенный в кавычки, конвертируется ассемблером в ASCII, в то время как одиночный
ноль является байтом `0x00`.

Управляющие конструкции
------------------

Ранее уже была использована одна: `jmp $` для бесконечного цикла

Переход, определяющийся результатом проверки условия (аналог if...else):

```nasm
cmp ax, 4      ; if ax = 4
je ax_is_four  ; do something (by jumping to that label)
jmp else       ; else, do another thing
jmp endif      ; finally, resume the normal flow

ax_is_four:
    .....
    jmp endif

else:
    .....
    jmp endif  ; not actually necessary but printed here for completeness

endif:
```

Думайте на высоком уровне и преобразовывайте, таким образом, в команды ассемблера.

Есть много условий для `jmp`: если равно, если меньше чем, и т.п. Они красивые и интуитивно понятные. А самое главное
их всегда можно найти с помощью Google.

>***Примечания переводчика**:* можно посмотреть на странице [условные и безусловные переходы](http://asmworld.ru/uchebnyj-kurs/016-uslovnye-i-bezuslovnye-perexody/) 
учебника по ассемблеру 


Вызов функций
-----------------

Как вы можете предположить, вызов функций это простой переход к метке.

Сложной частью являются параметры. Есть два варианта работы с ними:

1. Программист может использовать специальные регистры, либо адреса в памяти.
2. Написать больше кода для того чтобы сделать вызовы функций обобщенными и этим избавиться от проблем.

Первый вариант очень простой. Давайте придем к соглашению, что будем использовать `al` (на самом деле `ax`) для 
параметров. Например:

```nasm
mov al, 'X'
jmp print
endprint:

...

print:
    mov ah, 0x0e  ; tty режим
    int 0x10      ; предполагаем, что в 'al' уже содержится необходимый символ
    jmp endprint  ; эта метка также считается предварительно согласованной
```

Уже сейчас можно заметить, что вскоре код превратится в спагетти. Текущая функция `print` будет возвращаться всегда
в одну и ту же точку - `endprint`. А что если в другом участке кода необходимо ее вызвать. Вышеприведенным кодом мы 
убиваем повторное использование нашего кода.

Правильное решение предлагает два улучшения:

- Мы будем сохранять обратный адрес для возвращения в нужную точку.
- Мы сохраним текущие значения регистров, чтобы случайно их не изменить, убрав некоторые побочные эффекты.

Процессор поможет нам сохранять обратный адрес. Вместо использования пары `jmp` мы применим команды `call` и `ret`

Для сохранения и восстановления значений регистров тоже есть специальные команды, которые используют стек: `pusha`
и `popa`. Первая команда помещает все регистры в стек, а вторая - вытаскивает их обратно.

Подключение внешних файлов
------------------------

Я предполагаю, что вы программист, и мне не нужно убеждать вас, почему это хорошая идея.

Синтаксис включения прост:
```nasm
%include "file.asm"
```

Печать шестнадцатиричных значений
-------------------

На следующем уроке мы начнем читать с диска, поэтому нам нужен какой-то способ
чтобы убедиться, что мы читаем правильные данные. Файл `boot_sect_print_hex.asm`
расширяет `boot_sect_print.asm` для вывода шестнадцатеричных байтов, а не только символов ASCII.

Код! 
-----

Позвольте перейти к коду. Файл `boot_sect_print.asm` это подпрограмма, которая подключается с помощью `%include`
в основном файле. Он использует цикл для вывода байтов на экран, а также добавляет переход на новую строку. Знакомый
символ `'\n'` состоит из двух байт: перевод на новую строку - `0x0A` и возврат каретки в начало строки - `0x0D`.
Поэкспериментируйте, удалив возврат каретки, и вы увидите какой будет эффект.

Как указано выше, `boot_sect_print_hex.asm` позволяет печатать байты.

Основной файл `boot_sect_main.asm` вызывает `print` и` print_hex` и зависает. Если вы поняли
предыдущие разделы, это довольно просто.
